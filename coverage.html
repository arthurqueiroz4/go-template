
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">crud-golang/api/controller/category_controller.go (0.0%)</option>
				
				<option value="file1">crud-golang/api/middleware/validation.go (0.0%)</option>
				
				<option value="file2">crud-golang/api/route/category_route.go (0.0%)</option>
				
				<option value="file3">crud-golang/api/route/route.go (0.0%)</option>
				
				<option value="file4">crud-golang/bootstrap/app.go (0.0%)</option>
				
				<option value="file5">crud-golang/bootstrap/database.go (0.0%)</option>
				
				<option value="file6">crud-golang/bootstrap/env.go (0.0%)</option>
				
				<option value="file7">crud-golang/cmd/main.go (0.0%)</option>
				
				<option value="file8">crud-golang/config/config.go (0.0%)</option>
				
				<option value="file9">crud-golang/docs/docs.go (0.0%)</option>
				
				<option value="file10">crud-golang/domain/category.go (100.0%)</option>
				
				<option value="file11">crud-golang/mock/mock_category.go (48.5%)</option>
				
				<option value="file12">crud-golang/repository/base_repository.go (0.0%)</option>
				
				<option value="file13">crud-golang/repository/category_repository.go (0.0%)</option>
				
				<option value="file14">crud-golang/service/category_service.go (83.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "crud-golang/api/dto"
        "crud-golang/domain"
        "github.com/PeteProgrammer/go-automapper"
        "github.com/gofiber/fiber/v2"
)

type CategoryController struct {
        cs domain.CategoryService
}

func NewCategoryController(cs domain.CategoryService) *CategoryController <span class="cov0" title="0">{
        return &amp;CategoryController{
                cs: cs,
        }
}</span>

// Create Category
//
// @Summary Create a new category
// @Description Create a new category with the provided details
// @Tags Categories
// @Accept json
// @Produce json
// @Param category body dto.CategoryDTO true "Category DTO"
// @Success 200 {object} dto.CategoryDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /categories [post]
func (cc *CategoryController) Create(c *fiber.Ctx) error <span class="cov0" title="0">{
        var categoryDTO dto.CategoryDTO

        if err := c.BodyParser(&amp;categoryDTO); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "Invalid request body"})
        }</span>

        <span class="cov0" title="0">var category domain.Category
        automapper.Map(categoryDTO, &amp;category)

        err := cc.cs.Create(&amp;category)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).
                        JSON(map[string]any{"message": "Could not create category"})
        }</span>

        <span class="cov0" title="0">automapper.Map(category, &amp;categoryDTO)

        return c.Status(fiber.StatusCreated).
                JSON(categoryDTO)</span>
}

// GetCategory
//
// @Summary Get a category by ID
// @Description Retrieve a category by its ID
// @Tags Categories
// @Produce json
// @Param id path int true "Category ID"
// @Success 200 {object} dto.CategoryDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /categories/{id} [get]
func (cc *CategoryController) GetCategory(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := c.ParamsInt("id")
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "ID is required"})
        }</span>
        <span class="cov0" title="0">category, err := cc.cs.GetById(id)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).
                        JSON(map[string]any{"message": "Category not found"})
        }</span>

        <span class="cov0" title="0">var categoryDTO dto.CategoryDTO
        automapper.Map(category, &amp;categoryDTO)
        return c.Status(fiber.StatusOK).
                JSON(categoryDTO)</span>
}

// DeleteCategory
//
// @Summary Delete a category by ID
// @Description Delete a category by its ID
// @Tags Categories
// @Param id path int true "Category ID"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /categories/{id} [delete]
func (cc *CategoryController) DeleteCategory(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := c.ParamsInt("id")
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "ID is required"})
        }</span>

        <span class="cov0" title="0">err = cc.cs.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).
                        JSON(map[string]any{"message": "Category not found"})
        }</span>

        <span class="cov0" title="0">c.Status(fiber.StatusNoContent)
        return nil</span>
}

// UpdateCategory
//
// @Summary Update a category by ID
// @Description Update a category with the provided details
// @Tags Categories
// @Accept json
// @Produce json
// @Param id path int true "Category ID"
// @Param category body dto.CategoryDTO true "Category DTO"
// @Success 200 {object} dto.CategoryDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /categories/{id} [put]
func (cc *CategoryController) UpdateCategory(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := c.ParamsInt("id")
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "ID is required"})
        }</span>

        <span class="cov0" title="0">var categoryDTO dto.CategoryDTO
        if err := c.BodyParser(&amp;categoryDTO); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "Invalid request body"})
        }</span>

        <span class="cov0" title="0">var category domain.Category
        automapper.Map(categoryDTO, &amp;category)
        err = cc.cs.Update(id, &amp;category)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).
                        JSON(map[string]any{"message": "Category not found"})
        }</span>

        <span class="cov0" title="0">automapper.Map(category, &amp;categoryDTO)
        return c.Status(fiber.StatusOK).
                JSON(categoryDTO)</span>
}

// GetAllCategory
//
// @Summary Get all categories with pagination and optional filtering by name
// @Description Retrieve all categories, with pagination and optional filtering by name
// @Tags Categories
// @Produce json
// @Param page query int false "Page number" default(0)
// @Param size query int false "Page size" default(10)
// @Param name query string false "Category name"
// @Success 200 {array} dto.CategoryDTO
// @Failure 500 {object} map[string]interface{}
// @Router /categories [get]
func (cc *CategoryController) GetAllCategory(c *fiber.Ctx) error <span class="cov0" title="0">{
        page := c.QueryInt("page", 0)
        size := c.QueryInt("size", 10)
        name := c.Query("name")

        all, err := cc.cs.GetAll(page, size, name)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).
                        JSON(map[string]any{"message": "Internal server error"})
        }</span>

        <span class="cov0" title="0">var dtos []dto.CategoryDTO
        automapper.Map(all, &amp;dtos)
        return c.Status(fiber.StatusOK).
                JSON(dtos)</span>
}

// GetAllActive
//
// @Summary Get all categories with pagination and filtering by active
// @Description Retrieve all categories, with pagination and filtering by active
// @Tags Categories
// @Produce json
// @Param page query int false "Page number" default(0)
// @Param size query int false "Page size" default(10)
// @Success 200 {array} dto.CategoryDTO
// @Failure 500 {object} map[string]interface{}
// @Router /categories/active [get]
func (cc *CategoryController) GetAllActive(c *fiber.Ctx) error <span class="cov0" title="0">{
        page := c.QueryInt("page", 0)
        size := c.QueryInt("size", 10)

        all, err := cc.cs.GetAllActive(page, size)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).
                        JSON(map[string]any{"message": "Internal server error"})
        }</span>

        <span class="cov0" title="0">var dtos []dto.CategoryDTO
        automapper.Map(all, &amp;dtos)
        return c.Status(fiber.StatusOK).
                JSON(dtos)</span>
}

// UpdateActiveById
//
// @Summary Update a category status by ID
// @Description Update a category activation status
// @Tags Categories
// @Accept json
// @Produce json
// @Param id path int true "Category ID"
// @Param categoryActive body dto.CategoryDTOActive true "Category DTO Active"
// @Success 200 {object} dto.CategoryDTO
// @Router /categories/active/{id} [patch]
func (cc *CategoryController) UpdateActiveById(c *fiber.Ctx) error <span class="cov0" title="0">{
        id, err := c.ParamsInt("id")
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "ID is required"})
        }</span>

        <span class="cov0" title="0">var categoryDTOActive dto.CategoryDTOActive
        if err := c.BodyParser(&amp;categoryDTOActive); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).
                        JSON(map[string]any{"message": "Invalid request body"})
        }</span>

        <span class="cov0" title="0">category, err := cc.cs.UpdateActive(id, categoryDTOActive.Active)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusNotFound).
                        JSON(map[string]any{"message": "Category not found"})
        }</span>

        <span class="cov0" title="0">var categoryDTO dto.CategoryDTO
        automapper.Map(category, &amp;categoryDTO)
        return c.Status(fiber.StatusOK).
                JSON(categoryDTO)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "github.com/go-playground/validator/v10"
        "github.com/gofiber/fiber/v2"
)

type ErrorMessage struct {
        Field string `json:"field"`
        Tag   string `json:"tag"`
        Error string `json:"error"`
}

var Validator = validator.New()

func ValidationBody[T any](c *fiber.Ctx) error <span class="cov0" title="0">{
        var errors []*ErrorMessage
        body := new(T)
        err := c.BodyParser(body)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(ErrorMessage{Error: err.Error()})
        }</span>

        <span class="cov0" title="0">err = Validator.Struct(body)
        if err != nil </span><span class="cov0" title="0">{
                for _, err := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                        var el ErrorMessage
                        el.Field = err.Field()
                        el.Tag = err.Tag()
                        el.Error = err.Error()
                        errors = append(errors, &amp;el)
                }</span>
                <span class="cov0" title="0">return c.Status(fiber.StatusBadRequest).JSON(errors)</span>
        }
        <span class="cov0" title="0">return c.Next()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package route

import (
        "crud-golang/api/controller"
        "crud-golang/api/dto"
        "crud-golang/api/middleware"
        "crud-golang/repository"
        "crud-golang/service"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"
)

func NewCategoryRouter(db gorm.DB, r fiber.Router) <span class="cov0" title="0">{
        cdb := repository.NewCategoryRepository(&amp;db)
        cs := service.NewCategoryService(cdb)
        cc := controller.NewCategoryController(cs)

        r.Get("categories/", cc.GetAllCategory)
        r.Get("categories/active", cc.GetAllActive)
        r.Get("categories/:id", cc.GetCategory)
        r.Post("categories/", middleware.ValidationBody[dto.CategoryDTO], cc.Create)
        r.Delete("categories/:id", cc.DeleteCategory)
        r.Put("categories/:id", middleware.ValidationBody[dto.CategoryDTO], cc.UpdateCategory)
        r.Patch("categories/active/:id", middleware.ValidationBody[dto.CategoryDTOActive], cc.UpdateActiveById)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package route

import (
        _ "crud-golang/docs"
        swagger "github.com/arsmn/fiber-swagger/v2"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "gorm.io/gorm"
)

// @title Category CRUD
// @version 1.0
// @description This is a sample CRUD.
// @contact.name API Support
// @contact.url http://suport.com
// @contact.email support@dev.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8000
// @BasePath /
// @schemes http
func Setup(db gorm.DB, app *fiber.App) <span class="cov0" title="0">{

        app.Use(recover.New())
        app.Use(logger.New(logger.Config{
                Format:     "${time} | ${status} | ${latency} | ${ip} | ${method} | ${path} | ${error}\n",
                TimeFormat: "2006-01-02 15:04:05",
                TimeZone:   "America/Sao_Paulo",
        }))

        publicRouter := app.Group("")
        publicRouter.Get("/swagger/*", swagger.HandlerDefault)
        //privateRouter := app.Group("")

        NewCategoryRouter(db, publicRouter)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bootstrap

import "gorm.io/gorm"

type Application struct {
        Env      *Env
        Postgres gorm.DB
}

func App() Application <span class="cov0" title="0">{
        app := Application{}
        app.Env = NewEnv()
        app.Postgres = NewPostgresDatabase(app.Env)
        return app
}</span>

func (app *Application) CloseDBConnection() <span class="cov0" title="0">{
        ClosePostgresDatabase(app.Postgres)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package bootstrap

import (
        "context"
        "crud-golang/domain"
        "errors"
        "fmt"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "log"
        "time"
)

func NewPostgresDatabase(env *Env) gorm.DB <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        dbHost := env.DBHost
        dbPort := env.DBPort
        dbUser := env.DBUser
        dbPassword := env.DBPassword
        dbName := env.DBName

        dsn := fmt.Sprintf(
                "host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=America/Sao_Paulo",
                dbHost, dbUser, dbPassword, dbName, dbPort,
        )

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic(errors.New("failed to connection to database"))</span>
        }

        <span class="cov0" title="0">sqlDB, _ := db.DB()
        if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                panic(errors.New("failed to ping database"))</span>
        }

        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)
        sqlDB.SetConnMaxLifetime(time.Hour)

        db.AutoMigrate(&amp;domain.Category{})

        ctx.Done()

        log.Println("Database connection established")
        return *db</span>
}

func ClosePostgresDatabase(db gorm.DB) <span class="cov0" title="0">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = sqlDB.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">log.Printf("Connection to database closed.")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bootstrap

import (
        "github.com/spf13/viper"
        "log"
)

type Env struct {
        AppEnv        string `mapstructure:"APP_ENV"`
        DBDriver      string `mapstructure:"DB_DRIVER"`
        DBHost        string `mapstructure:"DB_HOST"`
        DBPort        string `mapstructure:"DB_PORT"`
        DBUser        string `mapstructure:"DB_USER"`
        DBPassword    string `mapstructure:"DB_PASSWORD"`
        DBName        string `mapstructure:"DB_NAME"`
        WebServerPort string `mapstructure:"PORT"`
}

func NewEnv() *Env <span class="cov0" title="0">{
        env := Env{}
        viper.SetConfigFile(".env")

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Can't find the file .env : ", err)
        }</span>

        <span class="cov0" title="0">err = viper.Unmarshal(&amp;env)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Environment can't be loaded: ", err)
        }</span>

        <span class="cov0" title="0">if env.AppEnv == "development" </span><span class="cov0" title="0">{
                log.Println("The App is running in development env")
        }</span>

        <span class="cov0" title="0">return &amp;env</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "crud-golang/api/route"
        "crud-golang/bootstrap"
        "github.com/gofiber/fiber/v2"
        "log"
)

//TODO Return Page in GETs
/*
TODO write readme with explanation about:
        "How gen mocks for tests? &lt; mockgen -source=category.go -destination=./mock/mock_category.go &gt;",
        "Its need to generate swagger.json with SWAG CLI
        always when something changes for let swagger documentation updated."
*/

func main() <span class="cov0" title="0">{
        app := bootstrap.App()

        env := app.Env

        db := app.Postgres
        defer app.CloseDBConnection()

        appFiber := fiber.New()

        route.Setup(db, appFiber)

        log.Fatal(appFiber.Listen(env.WebServerPort))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import "github.com/spf13/viper"

type Cfg struct {
        DBDriver      string `mapstructure:"DB_DRIVER"`
        DBHost        string `mapstructure:"DB_HOST"`
        DBPort        string `mapstructure:"DB_PORT"`
        DBUser        string `mapstructure:"DB_USER"`
        DBPassword    string `mapstructure:"DB_PASSWORD"`
        DBName        string `mapstructure:"DB_NAME"`
        WebServerPort string `mapstructure:"PORT"`
}

func LoadConfig() *Cfg <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("env")
        viper.AddConfigPath(".")
        viper.SetConfigFile(".env")
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var c Cfg
        if err := viper.Unmarshal(&amp;c); err != nil </span><span class="cov0" title="0">{
                panic("config not loaded")</span>
        }

        <span class="cov0" title="0">return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/categories": {
            "get": {
                "description": "Retrieve all categories, with pagination and optional filtering by name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Get all categories with pagination and optional filtering by name",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Category name",
                        "name": "name",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.CategoryDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new category with the provided details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Create a new category",
                "parameters": [
                    {
                        "description": "Category DTO",
                        "name": "category",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/categories/active": {
            "get": {
                "description": "Retrieve all categories, with pagination and filtering by active",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Get all categories with pagination and filtering by active",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Page size",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.CategoryDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/categories/active/{id}": {
            "patch": {
                "description": "Update a category activation status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Update a category status by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Category DTO Active",
                        "name": "categoryActive",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTOActive"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    }
                }
            }
        },
        "/categories/{id}": {
            "get": {
                "description": "Retrieve a category by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Get a category by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update a category with the provided details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Update a category by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Category DTO",
                        "name": "category",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.CategoryDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a category by its ID",
                "tags": [
                    "Categories"
                ],
                "summary": "Delete a category by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.CategoryDTO": {
            "type": "object",
            "required": [
                "name"
            ],
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "dto.CategoryDTOActive": {
            "type": "object",
            "properties": {
                "active": {
                    "type": "boolean"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

type Category struct {
        ID     uint `gorm:"primary_key;auto_increment"`
        Name   string
        Active bool
}

type CategoryRepository interface {
        BaseRepository[Category]
        FindAllSpec(int, int, string) ([]Category, error)
}

type CategoryService interface {
        GetAllActive(int, int) ([]Category, error)
        GetAll(int, int, string) ([]Category, error)
        GetById(int) (*Category, error)
        Create(*Category) error
        Update(int, *Category) error
        UpdateActive(int, bool) (*Category, error)
        Delete(int) error
}

func NewCategory(id uint, name string, active bool) *Category <span class="cov8" title="1">{
        return &amp;Category{
                Name:   name,
                ID:     id,
                Active: active,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./domain/category.go
//
// Generated by this command:
//
//        mockgen -source=./domain/category.go -destination=./mock/mock_category.go
//

// Package mock_domain is a generated GoMock package.
package mock_domain

import (
        domain "crud-golang/domain"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockCategoryRepository is a mock of CategoryRepository interface.
type MockCategoryRepository struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryRepositoryMockRecorder
}

// MockCategoryRepositoryMockRecorder is the mock recorder for MockCategoryRepository.
type MockCategoryRepositoryMockRecorder struct {
        mock *MockCategoryRepository
}

// NewMockCategoryRepository creates a new mock instance.
func NewMockCategoryRepository(ctrl *gomock.Controller) *MockCategoryRepository <span class="cov8" title="1">{
        mock := &amp;MockCategoryRepository{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryRepository) EXPECT() *MockCategoryRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockCategoryRepository) Create(arg0 *domain.Category) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockCategoryRepositoryMockRecorder) Create(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCategoryRepository)(nil).Create), arg0)
}</span>

// Delete mocks base method.
func (m *MockCategoryRepository) Delete(arg0 int) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCategoryRepositoryMockRecorder) Delete(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCategoryRepository)(nil).Delete), arg0)
}</span>

// FindAll mocks base method.
func (m *MockCategoryRepository) FindAll(arg0, arg1 int, arg2 ...string) ([]domain.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []any{arg0, arg1}
        for _, a := range arg2 </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "FindAll", varargs...)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// FindAll indicates an expected call of FindAll.
func (mr *MockCategoryRepositoryMockRecorder) FindAll(arg0, arg1 any, arg2 ...any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockCategoryRepository)(nil).FindAll), varargs...)
}</span>

// FindAllSpec mocks base method.
func (m *MockCategoryRepository) FindAllSpec(arg0, arg1 int, arg2 string) ([]domain.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAllSpec", arg0, arg1, arg2)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAllSpec indicates an expected call of FindAllSpec.
func (mr *MockCategoryRepositoryMockRecorder) FindAllSpec(arg0, arg1, arg2 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllSpec", reflect.TypeOf((*MockCategoryRepository)(nil).FindAllSpec), arg0, arg1, arg2)
}</span>

// FindByID mocks base method.
func (m *MockCategoryRepository) FindByID(arg0 int) (*domain.Category, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", arg0)
        ret0, _ := ret[0].(*domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockCategoryRepositoryMockRecorder) FindByID(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockCategoryRepository)(nil).FindByID), arg0)
}</span>

// Update mocks base method.
func (m *MockCategoryRepository) Update(arg0 *domain.Category) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockCategoryRepositoryMockRecorder) Update(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockCategoryRepository)(nil).Update), arg0)
}</span>

// MockCategoryService is a mock of CategoryService interface.
type MockCategoryService struct {
        ctrl     *gomock.Controller
        recorder *MockCategoryServiceMockRecorder
}

// MockCategoryServiceMockRecorder is the mock recorder for MockCategoryService.
type MockCategoryServiceMockRecorder struct {
        mock *MockCategoryService
}

// NewMockCategoryService creates a new mock instance.
func NewMockCategoryService(ctrl *gomock.Controller) *MockCategoryService <span class="cov0" title="0">{
        mock := &amp;MockCategoryService{ctrl: ctrl}
        mock.recorder = &amp;MockCategoryServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCategoryService) EXPECT() *MockCategoryServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockCategoryService) Create(arg0 *domain.Category) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockCategoryServiceMockRecorder) Create(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCategoryService)(nil).Create), arg0)
}</span>

// Delete mocks base method.
func (m *MockCategoryService) Delete(arg0 int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCategoryServiceMockRecorder) Delete(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCategoryService)(nil).Delete), arg0)
}</span>

// GetAll mocks base method.
func (m *MockCategoryService) GetAll(arg0, arg1 int, arg2 string) ([]domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", arg0, arg1, arg2)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockCategoryServiceMockRecorder) GetAll(arg0, arg1, arg2 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockCategoryService)(nil).GetAll), arg0, arg1, arg2)
}</span>

// GetAllActive mocks base method.
func (m *MockCategoryService) GetAllActive(arg0, arg1 int) ([]domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllActive", arg0, arg1)
        ret0, _ := ret[0].([]domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllActive indicates an expected call of GetAllActive.
func (mr *MockCategoryServiceMockRecorder) GetAllActive(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllActive", reflect.TypeOf((*MockCategoryService)(nil).GetAllActive), arg0, arg1)
}</span>

// GetById mocks base method.
func (m *MockCategoryService) GetById(arg0 int) (*domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetById", arg0)
        ret0, _ := ret[0].(*domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetById indicates an expected call of GetById.
func (mr *MockCategoryServiceMockRecorder) GetById(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetById", reflect.TypeOf((*MockCategoryService)(nil).GetById), arg0)
}</span>

// Update mocks base method.
func (m *MockCategoryService) Update(arg0 int, arg1 *domain.Category) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockCategoryServiceMockRecorder) Update(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockCategoryService)(nil).Update), arg0, arg1)
}</span>

// UpdateActive mocks base method.
func (m *MockCategoryService) UpdateActive(arg0 int, arg1 bool) (*domain.Category, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateActive", arg0, arg1)
        ret0, _ := ret[0].(*domain.Category)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateActive indicates an expected call of UpdateActive.
func (mr *MockCategoryServiceMockRecorder) UpdateActive(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActive", reflect.TypeOf((*MockCategoryService)(nil).UpdateActive), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "crud-golang/domain"
        "gorm.io/gorm"
)

type BaseRepository[T any] struct {
        DB *gorm.DB
}

func NewBaseRepository[T any](db *gorm.DB) BaseRepository[T] <span class="cov0" title="0">{
        return BaseRepository[T]{DB: db}
}</span>

func (b *BaseRepository[T]) Create(category *T) error <span class="cov0" title="0">{
        if err := b.DB.Create(category).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *BaseRepository[T]) FindAll(page, limit int, params ...string) ([]T, error) <span class="cov0" title="0">{
        var entity []T
        query := b.DB

        for _, param := range params </span><span class="cov0" title="0">{
                query = query.Where(param)
        }</span>

        <span class="cov0" title="0">if err := query.Limit(limit).Offset(page * limit).Find(&amp;entity).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}

func (b *BaseRepository[T]) FindByID(id int) (*T, error) <span class="cov0" title="0">{
        var entity T
        if err := b.DB.First(&amp;entity, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;entity, nil</span>
}

func (b *BaseRepository[T]) Update(entity *T) error <span class="cov0" title="0">{
        if err := b.DB.Save(entity).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *BaseRepository[T]) Delete(id int) error <span class="cov0" title="0">{
        if err := b.DB.Delete(&amp;domain.Category{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "crud-golang/domain"
        "gorm.io/gorm"
)

type CategoryRepository struct {
        BaseRepository[domain.Category]
}

func NewCategoryRepository(db *gorm.DB) *CategoryRepository <span class="cov0" title="0">{
        return &amp;CategoryRepository{NewBaseRepository[domain.Category](db)}
}</span>

func (c *CategoryRepository) FindAllSpec(page, size int, name string) ([]domain.Category, error) <span class="cov0" title="0">{
        var categories []domain.Category
        query := c.DB
        if name != "" </span><span class="cov0" title="0">{
                query = query.Where("name LIKE ?", "%"+name+"%")
        }</span>

        <span class="cov0" title="0">query = query.Limit(size).Offset(page * size).Order("name asc")

        if err := query.Find(&amp;categories).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "crud-golang/domain"
        "errors"
)

type CategoryService struct {
        cr domain.CategoryRepository
}

func NewCategoryService(categoryRepository domain.CategoryRepository) domain.CategoryService <span class="cov8" title="1">{
        return &amp;CategoryService{
                cr: categoryRepository,
        }
}</span>

func (cs *CategoryService) Create(category *domain.Category) error <span class="cov8" title="1">{
        err := cs.cr.Create(category)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("category creation failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cs *CategoryService) GetById(id int) (*domain.Category, error) <span class="cov8" title="1">{
        category, err := cs.cr.FindByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov8" title="1">return category, nil</span>
}

func (cs *CategoryService) GetAll(page, size int, name string) ([]domain.Category, error) <span class="cov8" title="1">{
        all, err := cs.cr.FindAllSpec(page, size, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("category list failed")
        }</span>

        <span class="cov8" title="1">return all, nil</span>
}

func (cs *CategoryService) Update(id int, categoryToUpdate *domain.Category) error <span class="cov8" title="1">{
        if _, err := cs.GetById(id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">categoryToUpdate.ID = uint(id)
        err := cs.cr.Update(categoryToUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("category update failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cs *CategoryService) Delete(id int) error <span class="cov8" title="1">{
        if _, err := cs.GetById(id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return cs.cr.Delete(id)</span>
}

func (cs *CategoryService) GetAllActive(page, size int) ([]domain.Category, error) <span class="cov8" title="1">{
        queryForActive := "active = true"

        all, err := cs.cr.FindAll(page, size, queryForActive)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("category list failed")
        }</span>

        <span class="cov8" title="1">return all, nil</span>
}

func (cs *CategoryService) UpdateActive(id int, active bool) (*domain.Category, error) <span class="cov8" title="1">{
        categoryToUpdate, err := cs.GetById(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov8" title="1">categoryToUpdate.ID = uint(id)
        categoryToUpdate.Active = active
        err = cs.cr.Update(categoryToUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("category update active failed")
        }</span>

        <span class="cov8" title="1">return categoryToUpdate, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
